# -*- coding: utf-8 -*-
"""Assign(20).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bGce2YICGLesiHv8IOPT5e_XNypbhesE

# Monthly Milk Production Forecasting Using RNN, LSTM, and GRU Deep Learning Models

Step 1: Identify the Business Problem :

The business currently relies on past production trends but lacks an automated forecasting system. This leads to inefficiencies in planning and resource allocation. A data-driven forecasting model is needed to predict future monthly milk production with high accuracy.

Step 2: Define the Objective :

The final outcome of this project is a reliable predictive system that provides future production estimates and visual insights. These forecasts can be used to optimize logistics, workforce planning, and resource allocation in the dairy industry.

Objective Statement:

To build and evaluate an RNN forecasting model that can:

- Predict upcoming monthly milk production with high accuracy
- Capture seasonal and long-term production patterns
- Support data-driven planning and decision-making
- Reduce uncertainty in supply chain and inventory management
- Improve operational efficiency and cost control

1.	Exploratory Data Analysis (EDA)
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import warnings
warnings.filterwarnings('ignore')
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import SimpleRNN, LSTM, GRU, Dense
from sklearn.metrics import mean_squared_error, mean_absolute_error

# Load dataset
df = pd.read_csv('monthly_milk_production.csv', index_col='Date', parse_dates=True)
df.columns = ['Production']

# Visualize the trend
df.plot(figsize=(12, 6), title='Monthly Milk Production')
plt.ylabel('Production (Pounds per Cow)')
plt.show()

"""2.	Data Preparation for Deep Learning"""

# Scale the data
scaler = MinMaxScaler()
scaled_data = scaler.fit_transform(df)

# Create sequences
def create_sequences(data, window_size=12):
    X, y = [], []
    for i in range(len(data) - window_size):
        X.append(data[i:i+window_size])
        y.append(data[i+window_size])
    return np.array(X), np.array(y)

X, y = create_sequences(scaled_data)

# Split into train and test sets (last 12 months for testing)
train_size = len(X) - 12
X_train, X_test = X[:train_size], X[train_size:]
y_train, y_test = y[:train_size], y[train_size:]

"""3.	Model Building

Model 1 - LSTM :
"""

lstm_model = Sequential([
    LSTM(50, activation='tanh', input_shape=(12,1)),
    Dense(1)
])

lstm_model.compile(optimizer='adam', loss='mse')

lstm_model.summary()

"""Train LSTM :"""

lstm_history = lstm_model.fit(
    X_train, y_train,
    epochs=50,
    batch_size=8,
    validation_data=(X_test, y_test)
)

"""Model 2 - Simple RNN :"""

rnn_model = Sequential()
rnn_model.add(SimpleRNN(50, activation='tanh', input_shape=(12,1)))
rnn_model.add(Dense(1))

rnn_model.compile(optimizer='adam', loss='mse')

rnn_model.summary()

"""Train RNN :"""

rnn_history = rnn_model.fit(
    X_train, y_train,
    epochs=50,
    batch_size=8,
    validation_data=(X_test, y_test)
)

"""Model 3 - GRU :"""

gru_model = Sequential([
    GRU(50, activation='tanh', input_shape=(12,1)),
    Dense(1)
])

gru_model.compile(optimizer='adam', loss='mse')

gru_model.summary()

"""Train GRU :"""

gru_history = gru_model.fit(
    X_train, y_train,
    epochs=50,
    batch_size=8,
    validation_data=(X_test, y_test)
)

"""4.	Model Evaluation"""

# Evaluation Function
def evaluate_models(models_dict, X_test, y_test, scaler):
    results = {}
    predictions_dict = {}

    # Actual values (inverse scaled)
    true_actual = scaler.inverse_transform(y_test.reshape(-1, 1))

    for name, model in models_dict.items():
        # Predict
        preds = model.predict(X_test)
        true_preds = scaler.inverse_transform(preds)
        predictions_dict[name] = true_preds

        # Calculate Metrics
        rmse = np.sqrt(mean_squared_error(true_actual, true_preds))
        mae = mean_absolute_error(true_actual, true_preds)
        mape = np.mean(np.abs((true_actual - true_preds) / true_actual)) * 100

        results[name] = {'RMSE': round(rmse, 2), 'MAE': round(mae, 2), 'MAPE': f"{round(mape, 2)}%"}

    return results, predictions_dict

# Example Usage (Assuming models are trained)
metrics, predictions = evaluate_models(
    {'RNN': rnn_model, 'LSTM': lstm_model, 'GRU': gru_model},
    X_test, y_test, scaler
)

# Display Comparison Table
metrics_df = pd.DataFrame(metrics).T
print("Performance Comparison:")
print(metrics_df)

"""Lower RMSE = better model -- Here RNN is better model compared to LSTM and GRU

5.	Prediction and Visualization

After training, we forecast for the next 12 months and compare the results with actual data.
"""

rnn_pred = scaler.inverse_transform(rnn_model.predict(X_test))
lstm_pred = scaler.inverse_transform(lstm_model.predict(X_test))
gru_pred = scaler.inverse_transform(gru_model.predict(X_test))

y_actual = scaler.inverse_transform(y_test)

"""Forecast milk production for the next 12 months"""

plt.figure(figsize=(12,6))

plt.plot(y_actual, label='Actual')
plt.plot(rnn_pred, label='RNN')
plt.plot(lstm_pred, label='LSTM')
plt.plot(gru_pred, label='GRU')

plt.legend()
plt.title("Model Comparison")
plt.show()

# Lower RMSE = better model -- Here RNN is better model compared to LSTM and GRU
# Predict on test data
predictions = rnn_model.predict(X_test)
true_predictions = scaler.inverse_transform(predictions)
actual_values = scaler.inverse_transform(y_test)

# Plot Results
plt.figure(figsize=(10, 5))
plt.plot(actual_values, label='Actual Production')
plt.plot(true_predictions, label='RNN Prediction')
plt.legend()
plt.title('Actual vs Predicted Milk Production')
plt.show()

"""Visualize the predicted trend with uncertainty or confidence intervals if possible.

Step 1 - Build LSTM with Dropout
"""

from tensorflow.keras.layers import LSTM, Dense, Dropout
from tensorflow.keras.models import Sequential

mc_model = Sequential([
    LSTM(50, return_sequences=False, input_shape=(12,1)),
    Dropout(0.2),   # introduces randomness
    Dense(1)
])

mc_model.compile(optimizer='adam', loss='mse')

mc_model.fit(X_train, y_train, epochs=50, batch_size=8)

"""Step 2 - Monte Carlo Predictions"""

def mc_dropout_predict(model, X, n_samples=100):
    preds = []
    for _ in range(n_samples):
        pred = model(X, training=True)  # dropout active
        preds.append(pred.numpy())
    return np.array(preds)

mc_preds = mc_dropout_predict(mc_model, X_test, 100)

"""Step 3 - Mean & Uncertainty"""

mean_pred = mc_preds.mean(axis=0)
std_pred = mc_preds.std(axis=0)

mean_pred = scaler.inverse_transform(mean_pred)
std_pred = scaler.inverse_transform(std_pred)
y_actual = scaler.inverse_transform(y_test)

"""Upper = mean + 2*std

Lower = mean - 2*std

Step 4 - Plot with Confidence Interval
"""

upper = mean_pred + 2*std_pred
lower = mean_pred - 2*std_pred

plt.figure(figsize=(12,6))

plt.plot(y_actual, label="Actual")
plt.plot(mean_pred, label="Predicted")

plt.fill_between(
    range(len(mean_pred)),
    lower.flatten(),
    upper.flatten(),
    alpha=0.3,
    label="Confidence Interval"
)

plt.legend()
plt.title("Prediction with Uncertainty")
plt.show()

"""- Blue line -> actual production
- Orange line -> predicted production
- Shaded region -> uncertainty range

Wider band = more uncertainty

Narrow band = confident prediction

This is exactly what businesses want

Confidence intervals were generated using Monte Carlo Dropout, where the model performed multiple stochastic forward passes. The mean prediction represents expected production, while the variance reflects uncertainty in the forecast.

6. Business Insights

The forecasting models reveal clear seasonal patterns and predictable fluctuations in monthly milk production. The predicted trends, along with uncertainty ranges, provide valuable decision-support information for the dairy business.

Interpretation of Results :

The model successfully captures recurring seasonal peaks and declines in production. This indicates that milk output is influenced by cyclical factors such as weather conditions, feed availability, and livestock productivity cycles. The uncertainty bands highlight months where predictions are less certain, suggesting higher operational risk.

The RNN/GRU model (best-performing model) demonstrates stable forecasting behavior, making it suitable for operational planning.

Strategic Recommendations :

Based on the forecasts, the dairy business can :

- Plan supply chain logistics in advance during high-production months
- Expand cold storage capacity before seasonal peaks to prevent spoilage
- Schedule maintenance and downtime during predicted low-production periods
- Optimize workforce allocation to match production demand
- Negotiate contracts and pricing based on expected supply levels
- Reduce waste and operational costs through accurate inventory planning
- Use uncertainty ranges to prepare contingency buffers

Risk Management Insight :

The confidence intervals help management understand risk exposure. Wider prediction ranges signal months where external factors may disrupt production. The company can prepare backup sourcing, reserve storage, or flexible labor strategies during these periods.

Business Value :

Accurate forecasting transforms reactive decision-making into proactive planning. By using these predictions, the dairy business can:

- Improve profitability
- Reduce waste
- Enhance operational efficiency
- Strengthen market competitiveness
- Support long-term strategic growth
"""